# MODELO CLASIFICACION ADABOOST

# Limpieza area de trabajo ------------------------------------------------
rm(list=ls())
cat('\014')

# Paquetes ----------------------------------------------------------------
require("pacman")
# cargar librerias 
p_load(tidyverse, # Manipular dataframes
       rio, # Importar datos fácilmente
       plotly, # Gráficos interactivos
       leaflet, # Mapas interactivos
       units, # unidades
       sf, # Leer/escribir/manipular datos espaciales
       osmdata, # Obtener datos de OpenStreetMap (OSM)
       tidymodels, # Modelado de datos limpios y ordenados
       randomForest, # Modelos de bosque aleatorio
       rattle, # Interfaz gráfica para el modelado de datos
       spatialsample, # Muestreo espacial para modelos de aprendizaje automático
       xgboost,
       purrr,
       glmnet) 
#Creación de subsets de entrenamiento y prueba
train <-  bd %>%
  subset(sample == "train")

# crear subset de testeo
test <- bd %>%
  subset(sample == "test")


##Crear un recipe para ambos modelos:
receta<-recipe(pobre~., data=train)%>%
  step_normalize(all_numeric_predictors()) %>% # Centramos todas las variables
  step_scale(all_predictors()) # Reescalamos
  step_rm()

# Instalar y cargar el paquete adabag
install.packages("adabag")
library(adabag)

# Crear un conjunto de entrenamiento balanceado mediante SMOTE
set.seed(123)  # Fijar semilla para reproducibilidad
over_train_smote <- SMOTE(pobre ~ ., data = train, perc.over = 100, perc.under = 200)

# Crear un modelo Adaboost de clasificación
modelo_adaboost <- boosting(pobre ~ ., data = over_train_smote$dataset, boos = TRUE, mfinal = 200)

# Realizar predicciones en el conjunto de prueba
predicciones_adaboost <- predict(boosting, newdata = test, model = modelo_adaboost)

# Crear un dataframe con las predicciones
resultados_adaboost <- data.frame(id = test$id, pobre = as.numeric(predicciones_adaboost$class) - 1)

# Guardar el archivo CSV con las predicciones
write.csv(resultados_adaboost, file = paste0(templates, 'clasificacion_adaboost.csv'), row.names = FALSE)